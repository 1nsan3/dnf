

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Base—The centerpiece of DNF &mdash; DNF 0.5.4-1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.5.4-1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="DNF 0.5.4-1 documentation" href="index.html" />
    <link rel="up" title="DNF API Reference" href="api.html" />
    <link rel="next" title="Exceptions" href="api_exceptions.html" />
    <link rel="prev" title="Common Provisions of the DNF API" href="api_common.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api_exceptions.html" title="Exceptions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="api_common.html" title="Common Provisions of the DNF API"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">DNF 0.5.4-1 documentation</a> &raquo;</li>
          <li><a href="api.html" accesskey="U">DNF API Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="base-the-centerpiece-of-dnf">
<h1><tt class="docutils literal"><span class="pre">Base</span></tt>&#8212;The centerpiece of DNF<a class="headerlink" href="#base-the-centerpiece-of-dnf" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="dnf.Base">
<em class="property">class </em><tt class="descclassname">dnf.</tt><tt class="descname">Base</tt><a class="headerlink" href="#dnf.Base" title="Permalink to this definition">¶</a></dt>
<dd><p>Instances of <a class="reference internal" href="#dnf.Base" title="dnf.Base"><tt class="xref py py-class docutils literal"><span class="pre">dnf.Base</span></tt></a> are the central point of functionality supplied by DNF. An application will typically create a single instance of this class which it will keep for the runtime needed to accomplish its packaging tasks. Plugins are managed by DNF and get a reference to <a class="reference internal" href="#dnf.Base" title="dnf.Base"><tt class="xref py py-class docutils literal"><span class="pre">dnf.Base</span></tt></a> object when they run.</p>
<p><a class="reference internal" href="#dnf.Base" title="dnf.Base"><tt class="xref py py-class docutils literal"><span class="pre">Base</span></tt></a> instances are stateful objects holding references to various data sources and data sinks. To properly finalize and close off any handles the object may hold, client code should either call <a class="reference internal" href="#dnf.Base.close" title="dnf.Base.close"><tt class="xref py py-meth docutils literal"><span class="pre">Base.close()</span></tt></a> when it has finished opertions with the instance, or use the instance as a context manager. After the object has left the context, or its <a class="reference internal" href="#dnf.Base.close" title="dnf.Base.close"><tt class="xref py py-meth docutils literal"><span class="pre">Base.close()</span></tt></a> has been called explicitly, it must not be used.</p>
<dl class="attribute">
<dt id="dnf.Base.comps">
<tt class="descname">comps</tt><a class="headerlink" href="#dnf.Base.comps" title="Permalink to this definition">¶</a></dt>
<dd><p>Is <tt class="docutils literal"><span class="pre">None</span></tt> by default. Explicit load via <a class="reference internal" href="#dnf.Base.read_comps" title="dnf.Base.read_comps"><tt class="xref py py-meth docutils literal"><span class="pre">read_comps()</span></tt></a>  initializes this attribute to a <a class="reference internal" href="api_comps.html#dnf.comps.Comps" title="dnf.comps.Comps"><tt class="xref py py-class docutils literal"><span class="pre">dnf.comps.Comps</span></tt></a> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="dnf.Base.conf">
<tt class="descname">conf</tt><a class="headerlink" href="#dnf.Base.conf" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="api_conf.html#dnf.conf.Conf" title="dnf.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">dnf.conf.Conf</span></tt></a>, concentrates all the different configuration options. <a class="reference internal" href="#dnf.Base.__init__" title="dnf.Base.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> initializes this to usable defaults.</p>
</dd></dl>

<dl class="attribute">
<dt id="dnf.Base.repos">
<tt class="descname">repos</tt><a class="headerlink" href="#dnf.Base.repos" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="api_repos.html#dnf.repodict.RepoDict" title="dnf.repodict.RepoDict"><tt class="xref py py-class docutils literal"><span class="pre">dnf.repodict.RepoDict</span></tt></a> instance, this member object contains all the repositories available.</p>
</dd></dl>

<dl class="attribute">
<dt id="dnf.Base.sack">
<tt class="descname">sack</tt><a class="headerlink" href="#dnf.Base.sack" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="api_sack.html#dnf.sack.Sack" title="dnf.sack.Sack"><tt class="xref py py-class docutils literal"><span class="pre">Sack</span></tt></a> that this <a class="reference internal" href="#dnf.Base" title="dnf.Base"><tt class="xref py py-class docutils literal"><span class="pre">Base</span></tt></a> object is using. It needs to be explicitly initialized by <a class="reference internal" href="#dnf.Base.fill_sack" title="dnf.Base.fill_sack"><tt class="xref py py-meth docutils literal"><span class="pre">fill_sack()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="dnf.Base.transaction">
<tt class="descname">transaction</tt><a class="headerlink" href="#dnf.Base.transaction" title="Permalink to this definition">¶</a></dt>
<dd><p>A resolved transaction object, a <a class="reference internal" href="api_transaction.html#dnf.transaction.Transaction" title="dnf.transaction.Transaction"><tt class="xref py py-class docutils literal"><span class="pre">dnf.transaction.Transaction</span></tt></a> instance, or <tt class="docutils literal"><span class="pre">None</span></tt> if no transaction has been prepared yet.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dnf.Base.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Init an instance with a reasonable default configuration. The constructor takes no arguments.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.add_remote_rpm">
<tt class="descname">add_remote_rpm</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#dnf.Base.add_remote_rpm" title="Permalink to this definition">¶</a></dt>
<dd><p>Add RPM file at <cite>path</cite> to the <a class="reference internal" href="#dnf.Base.sack" title="dnf.Base.sack"><tt class="xref py py-attr docutils literal"><span class="pre">sack</span></tt></a> and return the respective <a class="reference internal" href="api_package.html#dnf.package.Package" title="dnf.package.Package"><tt class="xref py py-class docutils literal"><span class="pre">dnf.package.Package</span></tt></a> instance. Does the download to a temporary file if <cite>path</cite> is a remote URL. Raises <tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt> if there are problems obtaining or reading the file.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#dnf.Base.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all external handles the object holds. This is called automatically via context manager mechanism if the instance is handled using the <tt class="docutils literal"><span class="pre">with</span></tt> statement.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.fill_sack">
<tt class="descname">fill_sack</tt><big>(</big><span class="optional">[</span><em>load_system_repo=True</em>, <em>load_available_repos=True</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dnf.Base.fill_sack" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the package sack. If <cite>load_system_repo</cite> is <tt class="docutils literal"><span class="pre">True</span></tt>, load information about packages in the local RPMDB into the sack. Else no package is considered installed during dependency solving. If <cite>load_available_repos</cite> is <tt class="docutils literal"><span class="pre">True</span></tt>, load information about packages from the available repositories into the sack.</p>
<p>Before this method is invoked, the client application is supposed to have setup relevant configuration like the substitutions used in repository URLs. See <a class="reference internal" href="api_conf.html#dnf.conf.Conf.substitutions" title="dnf.conf.Conf.substitutions"><tt class="xref py py-attr docutils literal"><span class="pre">Conf.substitutions</span></tt></a>.</p>
<p>This operation can take a long time. Adding repositories or changing repositories&#8217; configuration does not affect the information within the sack until <a class="reference internal" href="#dnf.Base.fill_sack" title="dnf.Base.fill_sack"><tt class="xref py py-meth docutils literal"><span class="pre">fill_sack()</span></tt></a> has been called.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.do_transaction">
<tt class="descname">do_transaction</tt><big>(</big><span class="optional">[</span><em>display</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dnf.Base.do_transaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the resolved transaction. Use the optional <cite>display</cite> object to report the progress.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.download_packages">
<tt class="descname">download_packages</tt><big>(</big><em>pkglist</em>, <em>progress=None</em><big>)</big><a class="headerlink" href="#dnf.Base.download_packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Download packages in <cite>pkglist</cite> from remote repositories. Packages from local repositories or from the command line are not downloaded. <cite>progress</cite>, if given, should be a <a class="reference internal" href="api_callback.html#dnf.callback.DownloadProgress" title="dnf.callback.DownloadProgress"><tt class="xref py py-class docutils literal"><span class="pre">DownloadProgress</span></tt></a> and can be used by the caller to monitor the progress of the download. Raises <a class="reference internal" href="api_exceptions.html#dnf.exceptions.DownloadError" title="dnf.exceptions.DownloadError"><tt class="xref py py-exc docutils literal"><span class="pre">DownloadError</span></tt></a> if some packages failed to download.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.group_install">
<tt class="descname">group_install</tt><big>(</big><em>group</em>, <em>pkg_types</em>, <em>exclude=None</em><big>)</big><a class="headerlink" href="#dnf.Base.group_install" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark <cite>group</cite> (a <a class="reference internal" href="api_comps.html#dnf.comps.Group" title="dnf.comps.Group"><tt class="xref py py-class docutils literal"><span class="pre">dnf.comps.Group</span></tt></a> instance) installed and mark the packages in the group for installation. Return the number of packages that the operation has marked for installation. <cite>pkg_types</cite> is a sequence of strings determining the kinds of packages to be installed, where the respective groups can be selected by including <tt class="docutils literal"><span class="pre">&quot;mandatory&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;default&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;optional&quot;</span></tt> in it. If <cite>exclude</cite> is given, it has to be an iterable of package names: <a class="reference internal" href="#dnf.Base.group_install" title="dnf.Base.group_install"><tt class="xref py py-meth docutils literal"><span class="pre">group_install()</span></tt></a> will then not mark the respective packages for installation whenever possible (but e.g. packages tagged <em>mandatory</em> will be marked for intallation no matter the value of <cite>exlcude</cite>)</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.group_remove">
<tt class="descname">group_remove</tt><big>(</big><em>group</em><big>)</big><a class="headerlink" href="#dnf.Base.group_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark <cite>group</cite> (a <a class="reference internal" href="api_comps.html#dnf.comps.Group" title="dnf.comps.Group"><tt class="xref py py-class docutils literal"><span class="pre">dnf.comps.Group</span></tt></a> instance) not installed. All the packages marked as belonging to this group will be marked for removal. Return the number of packages marked for removal in this call.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.group_upgrade">
<tt class="descname">group_upgrade</tt><big>(</big><em>group</em><big>)</big><a class="headerlink" href="#dnf.Base.group_upgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Upgrade <cite>group</cite> (a <a class="reference internal" href="api_comps.html#dnf.comps.Group" title="dnf.comps.Group"><tt class="xref py py-class docutils literal"><span class="pre">dnf.comps.Group</span></tt></a> instance). If there has been packages added to the group&#8217;s comps information since installing on the system, they will be marked for installation. Similarly, removed packages get marked for removal. The remaining packages in the group are marked for an upgrade. The operation respects the package types from the original installation of the group.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.read_all_repos">
<tt class="descname">read_all_repos</tt><big>(</big><big>)</big><a class="headerlink" href="#dnf.Base.read_all_repos" title="Permalink to this definition">¶</a></dt>
<dd><p>Read repository configuration from the main configuration file specified by <a class="reference internal" href="api_conf.html#dnf.conf.Conf.config_file_path" title="dnf.conf.Conf.config_file_path"><tt class="xref py py-attr docutils literal"><span class="pre">dnf.conf.Conf.config_file_path</span></tt></a> and any <tt class="docutils literal"><span class="pre">.repo</span></tt> files under <a class="reference internal" href="api_conf.html#dnf.conf.Conf.reposdir" title="dnf.conf.Conf.reposdir"><tt class="xref py py-attr docutils literal"><span class="pre">dnf.conf.Conf.reposdir</span></tt></a>. All the repositories found this way are added to <a class="reference internal" href="#dnf.Base.repos" title="dnf.Base.repos"><tt class="xref py py-attr docutils literal"><span class="pre">repos</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.read_comps">
<tt class="descname">read_comps</tt><big>(</big><big>)</big><a class="headerlink" href="#dnf.Base.read_comps" title="Permalink to this definition">¶</a></dt>
<dd><p>Read comps data from all the enabled repositories and initialize the <a class="reference internal" href="#dnf.Base.comps" title="dnf.Base.comps"><tt class="xref py py-attr docutils literal"><span class="pre">comps</span></tt></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.reset">
<tt class="descname">reset</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#dnf.Base.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the state of different <a class="reference internal" href="#dnf.Base" title="dnf.Base"><tt class="xref py py-class docutils literal"><span class="pre">Base</span></tt></a> attributes. Selecting attributes to reset is controlled by passing the method keyword arguments set to <tt class="docutils literal"><span class="pre">True</span></tt>. When called with no arguments the method has no effect.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">argument passed</th>
<th class="head">effect</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>goal=True</cite></td>
<td>drop all the current <a class="reference internal" href="#package-marking-label"><em>packaging requests</em></a></td>
</tr>
<tr class="row-odd"><td><cite>repos=True</cite></td>
<td>drop the current repositries (see <a class="reference internal" href="#dnf.Base.repos" title="dnf.Base.repos"><tt class="xref py py-attr docutils literal"><span class="pre">repos</span></tt></a>). This won&#8217;t
affect the package data already loaded into the <a class="reference internal" href="#dnf.Base.sack" title="dnf.Base.sack"><tt class="xref py py-attr docutils literal"><span class="pre">sack</span></tt></a>.</td>
</tr>
<tr class="row-even"><td><cite>sack=True</cite></td>
<td>drop the current sack (see <a class="reference internal" href="#dnf.Base.sack" title="dnf.Base.sack"><tt class="xref py py-attr docutils literal"><span class="pre">sack</span></tt></a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.resolve">
<tt class="descname">resolve</tt><big>(</big><em>allow_erasing=True</em><big>)</big><a class="headerlink" href="#dnf.Base.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve the marked requirements and store the resulting <a class="reference internal" href="api_transaction.html#dnf.transaction.Transaction" title="dnf.transaction.Transaction"><tt class="xref py py-class docutils literal"><span class="pre">dnf.transaction.Transaction</span></tt></a> into <a class="reference internal" href="#dnf.Base.transaction" title="dnf.Base.transaction"><tt class="xref py py-attr docutils literal"><span class="pre">transaction</span></tt></a>. Raise <a class="reference internal" href="api_exceptions.html#dnf.exceptions.DepsolveError" title="dnf.exceptions.DepsolveError"><tt class="xref py py-exc docutils literal"><span class="pre">dnf.exceptions.DepsolveError</span></tt></a> on a depsolving error. Return <tt class="docutils literal"><span class="pre">True</span></tt> iff the resolved transaction is non-empty.</p>
<p>Enabling <cite>allow_erasing</cite> lets to solver remove other packages while looking to fulfill the current packaging requests. For instance, this is used to allow the solver remove dependants of a package being removed.</p>
<p>The exact operation of the solver further depends on the <a class="reference internal" href="api_conf.html#dnf.conf.Conf.best" title="dnf.conf.Conf.best"><tt class="xref py py-attr docutils literal"><span class="pre">dnf.conf.Conf.best</span></tt></a> setting.</p>
</dd></dl>

<p id="package-marking-label">The <a class="reference internal" href="#dnf.Base" title="dnf.Base"><tt class="xref py py-class docutils literal"><span class="pre">Base</span></tt></a> class provides a number of methods to make packaging requests that can later be resolved and turned into a transaction. The <cite>pkg_spec</cite> argument some of them take must be a package specification recognized by <a class="reference internal" href="api_queries.html#dnf.subject.Subject" title="dnf.subject.Subject"><tt class="xref py py-class docutils literal"><span class="pre">dnf.subject.Subject</span></tt></a>. If these methods fail to find suitable packages for the operation they raise a <a class="reference internal" href="api_exceptions.html#dnf.exceptions.MarkingError" title="dnf.exceptions.MarkingError"><tt class="xref py py-exc docutils literal"><span class="pre">MarkingError</span></tt></a>. Note that successful completion of these methods does not necessarily imply that the desired transaction can be carried out (e.g. for dependency reasons).</p>
<dl class="method">
<dt id="dnf.Base.downgrade">
<tt class="descname">downgrade</tt><big>(</big><em>pkg_spec</em><big>)</big><a class="headerlink" href="#dnf.Base.downgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark packages matching <cite>pkg_spec</cite> for downgrade.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.install">
<tt class="descname">install</tt><big>(</big><em>pkg_spec</em><big>)</big><a class="headerlink" href="#dnf.Base.install" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark packages matching <cite>pkg_spec</cite> for installation.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.package_downgrade">
<tt class="descname">package_downgrade</tt><big>(</big><em>pkg</em><big>)</big><a class="headerlink" href="#dnf.Base.package_downgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>pkg</cite> is a <a class="reference internal" href="api_package.html#dnf.package.Package" title="dnf.package.Package"><tt class="xref py py-class docutils literal"><span class="pre">dnf.package.Package</span></tt></a> in an available repository, mark the matching installed package for downgrade to <cite>pkg</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.package_install">
<tt class="descname">package_install</tt><big>(</big><em>pkg</em><big>)</big><a class="headerlink" href="#dnf.Base.package_install" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark <cite>pkg</cite> (a <a class="reference internal" href="api_package.html#dnf.package.Package" title="dnf.package.Package"><tt class="xref py py-class docutils literal"><span class="pre">dnf.package.Package</span></tt></a> instance) for installation.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.package_upgrade">
<tt class="descname">package_upgrade</tt><big>(</big><em>pkg</em><big>)</big><a class="headerlink" href="#dnf.Base.package_upgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>pkg</cite> is a <a class="reference internal" href="api_package.html#dnf.package.Package" title="dnf.package.Package"><tt class="xref py py-class docutils literal"><span class="pre">dnf.package.Package</span></tt></a> in an available repository, mark the matching installed package for upgrade to <cite>pkg</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.remove">
<tt class="descname">remove</tt><big>(</big><em>pkg_spec</em><big>)</big><a class="headerlink" href="#dnf.Base.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark packages matching <cite>pkg_spec</cite> for removal.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.upgrade">
<tt class="descname">upgrade</tt><big>(</big><em>pkg_spec</em><big>)</big><a class="headerlink" href="#dnf.Base.upgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark packages matching <cite>pkg_spec</cite> for upgrade.</p>
</dd></dl>

<dl class="method">
<dt id="dnf.Base.upgrade_all">
<tt class="descname">upgrade_all</tt><big>(</big><big>)</big><a class="headerlink" href="#dnf.Base.upgrade_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark all installed packages for an upgrade.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="api_common.html"
                        title="previous chapter">Common Provisions of the DNF API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api_exceptions.html"
                        title="next chapter">Exceptions</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/api_base.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api_exceptions.html" title="Exceptions"
             >next</a> |</li>
        <li class="right" >
          <a href="api_common.html" title="Common Provisions of the DNF API"
             >previous</a> |</li>
        <li><a href="index.html">DNF 0.5.4-1 documentation</a> &raquo;</li>
          <li><a href="api.html" >DNF API Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Red Hat, Licensed under GPLv2+.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>